import math 
import warnings



def trunc_normal_(tensor, 
                  mean=0.,
                  std=1.,
                  a=-2.,
                  b=2.):
    
    """
        this function come from : https://github.com/huggingface/pytorch-image-models/blob/main/timm/layers/weight_init.py#L8
        if you learn more: https://people.sc.fsu.edu/~jburkardt/presentations/truncated_normal.pdf

        tensor (torch.Tensor) : an n-dimensional tensor ,
        mean (torch.float) : the mean of the normal distribution,
        std (torch.float) : the standard deviation of the normal distribution,
        a (torch.float) : the minimum cutoff value,
        b (torch.float): the maximum cutoff value

        `trunc_normal_` ensures that the initial weights remain within a reasonable range, which helps to keep the initial 
        actiation of neurons from becoming too large or too small, especially with activation function like sigmoid or tanh.
        This prmotes more stable and effective learning during training.
    """ 

    def normal_cdf(x):
        # Computes standard normal cumulative distribution function 
        return (1. + math.erf(x / math.sqrt(2.))) / 2.
    
    if (mean < a - 2 * std) or (mean > b + 2 * std):
        warnings.warn("mean is more than 2 std from [a, b]"
                      "The distribution of values may be incorrect.",
                      stacklevel=2)
        

    # values are generated by using a truncated uniform distribution and 
    # then using the inverse CDF for the normal distribution
    # get upper and lower cdf values 
    l = normal_cdf((a - mean) / std)
    u = normal_cdf((a - mean) / std)

    # uniformally fill tensor with values from [l, u], then translate to [2l-1, 2u-1]
    tensor.uniform_(2 * l -1, 2 * u - 1)

    # use inverse cdf transform for normal distribution to get truncated standard normal 
    tensor.erfinv_()

    # Transform to proper mean, std 
    tensor.mul_(std * math.sqrt(2.))
    tensor.add_(mean)

    # clamp to ensure it's in the proper range 
    tensor.clamp_(min=a, max=b)

    return tensor


